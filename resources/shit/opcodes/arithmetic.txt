pub use crate::constants::*;
pub use crate::cpu::common::*;
use crate::cpu::{ProgramCounter, Registers};
use crate::Cpu;

/// This file contains all the functions necessary to support the Arithematic opcodes

impl Cpu {


    

    

    

    
    

    // Decimal Adjust Accumulator
    // If the least significant four bits of the accumulator have a value greater than nine,
    // or if the auxiliary carry flag is ON, DAA adds six to the accumulator.
    //
    // If the most significant four bits of the accumulator have a value greater than nine,
    // or if the carry flag IS ON, DAA adds six to the most significant four bits of the accumulator.
    pub fn op_daa(&mut self) -> ProgramCounter {
        // Find the LS4B of the accumulator
        let mut ac = false;
        let mut carry = false;

        if (self.a & 0b0000_1111) > 9 {
            let res = self.a.overflowing_add(6).0;
            ac = will_ac(6, self.a);
            self.a = res;
        }

        if (self.a & 0b1111_0000) > 9 {
            let (res, c) = self.a.overflowing_add(6 << 4);
            self.a = res;
            carry = c;
        }

        self.update_flags(self.a, Some(carry), Some(ac));

        ProgramCounter::Next
    }

    /// Add to the accumulator the supplied data byte after
    /// the opcode byte.
    ///
    /// If the parmeter ``carry_bit`` is true this performs the function
    /// of the opcode "ACI" by including the value of the carry bit in the
    /// addition.
    ///
    /// Condition bits affected: Carry, Sign, Zero, Parity, Aux Carry
    pub fn op_adi_aci(&mut self, dl: u8, carry_bit: bool) -> ProgramCounter {
        let mut to_add = dl;

        if carry_bit {
            to_add = to_add.overflowing_add(1).0; // Do we need to care about overflow here?
        };

        let ac = will_ac(to_add, self.a);
        let (res, of) = self.a.overflowing_add(to_add);
        self.a = res;
        self.update_flags(res, Some(of), Some(ac));

        ProgramCounter::Two
    }

    // Add to the accumulator the supplied register
    // along with the CARRY flag's value
    // as well as update flags
    pub fn op_adc(&mut self, register: Registers) -> ProgramCounter {
        let to_add: u8 = u8::from(self.test_flag(FLAG_CARRY))
            + match register {
                Registers::B => self.b,
                Registers::C => self.c,
                Registers::D => self.d,
                Registers::E => self.e,
                Registers::H => self.h,
                Registers::L => self.l,
                Registers::HL => self.memory[self.get_addr_pointer()],
                Registers::A => self.a,
                _ => 0_u8,
            };

        let (res, of) = self.a.overflowing_add(to_add);
        let ac = will_ac(to_add, self.a);
        self.a = res;
        self.update_flags(res, Some(of), Some(ac));

        ProgramCounter::Next
    }

    // Add to the accumulator the supplied register
    // as well as update flags
    pub fn op_add(&mut self, register: Registers) -> ProgramCounter {
        let to_add: u8 = match register {
            Registers::B => self.b,
            Registers::C => self.c,
            Registers::D => self.d,
            Registers::E => self.e,
            Registers::H => self.h,
            Registers::L => self.l,
            Registers::HL => self.memory[self.get_addr_pointer()],
            Registers::A => self.a,
            _ => 0_u8,
        };

        let (res, of) = self.a.overflowing_add(to_add);
        let ac = will_ac(to_add, self.a);
        self.a = res;
        self.update_flags(res, Some(of), Some(ac));

        ProgramCounter::Next
    }

    // Rotates right, if through_carry is true, it does that.
    pub fn op_rrc_rar(&mut self, through_carry: bool) -> ProgramCounter {
        // Store off our current carry bit
        let carry_bit = self.test_flag(FLAG_CARRY);
        let low_order = self.a & 0x01; // Save off the low order bit so we can rotate it.

        let mut new_accum: u8 = self.a >> 1;

        if through_carry {
            new_accum |= u8::from(carry_bit) << 7; // Carry bit replaces high order
        } else {
            // Normal carry
            new_accum |= low_order << 7; // Low order replaces high order
        };

        self.a = new_accum;

        if low_order > 0 {
            self.set_flag(FLAG_CARRY);
        } else {
            self.reset_flag(FLAG_CARRY);
        }

        ProgramCounter::Next
    }

    // CPI - Compare D16 to Accum, set flags accordingly
    pub fn op_cpi(&mut self, data: u8) -> ProgramCounter {
        // Subtract the data from register A and set flags on the result
        let (res, overflow) = self.a.overflowing_sub(data);
        let aux_carry = (self.a & 0x0F).wrapping_sub(data & 0x0F) > 0x0F;

        self.update_flags(res, Some(overflow), Some(aux_carry));

        ProgramCounter::Two
    }

    // Performs the Double Add (DAD) functionality
    // Sets H to the value according to the supplied register
    // Basically: HL = HL+<Selected register pair>
    pub fn op_dad(&mut self, source: Registers) -> ProgramCounter {
        //let val = usize::from(u16::from(self.h) << 8 | u16::from(self.l));
        let val = usize::from(self.get_register_pair(Registers::HL));

        let src: usize = match source {
            Registers::B | Registers::BC => usize::from(self.get_register_pair(Registers::BC)),
            Registers::D | Registers::DE => usize::from(self.get_register_pair(Registers::DE)),
            Registers::SP => usize::from(self.get_register_pair(Registers::SP)),
            Registers::H | Registers::HL => val,
            _ => 0,
        };

        let (new, of) = val.overflowing_add(src);

        self.h = (new >> 8) as u8;
        self.l = (new & 0xFF) as u8;

        if of {
            self.set_flag(FLAG_CARRY);
        }

        ProgramCounter::Next
    }

    



    

    // Sets a register to the compliment of itself
    pub fn op_comp(&mut self, register: Registers) -> ProgramCounter {
        if let Registers::A = register {
            self.a = !self.a;
        }
        ProgramCounter::Next
    }

    // Sets the carry flag to the compliment of itself
    pub fn op_cmc(&mut self) -> ProgramCounter {
        if self.test_flag(FLAG_CARRY) {
            // Flag needs to be reset
            self.reset_flag(FLAG_CARRY);
        } else {
            // Flag needs to be set
            self.set_flag(FLAG_CARRY);
        }
        ProgramCounter::Next
    }

    // Sets the carry flag
    pub fn op_stc(&mut self) -> ProgramCounter {
        self.set_flag(FLAG_CARRY);
        ProgramCounter::Next
    }
}
